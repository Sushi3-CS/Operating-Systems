# Chapter 2

- Introduction to operating systems
    
    프로그램을 실행했을 때? → Instruction들을, 즉 명령어들을 실행하게 됨. 초당 몇 billion의 횟수로 메모리 내용을 불러오고(fetch), 해석하며(decode), 실행한다(execute).
    
    이것이 바로 계산 시스템에서 Von Neumann(본 뉴마안 아니고 폰 노이만) 모델의 기본이다.
    
    물론, 말은 간단해도 실제 구현은 ㅈㄴ 복잡할 게 뻔하다. 그렇기에 이 책은 이러한 시스템을 보다 사용하기 쉽게 만드는 것을 일차적인 목표로 잡고 있다.
    
    결국, OS는 이러한 과정을 거쳐 프로그램을 실행할 수 있게 해 주는 주체라고 볼 수 있다. 이를 위해서는 여러 프로그램을 동시에 실행하고, 디바이스를 관리하는 등의 동작이 가능해야 한다.
    
    이를 쉽게 달성하려면 물리적인 자원을 보다 사용하기 쉬운 가상의 자원으로 바꿔먹어야 한다.
    
- Virtualizing the CPU
    
    책에서는 아름답고 놀라운 예제를 돌려서 설명하고 있지만, 나는 귀찮으니 안 돌릴거임. spin API를 사용해 1초에 하나의 출력을 내는 여러 프로그램을 동시에 실행시키며, 그 결과 모든 프로그램이 1초에 한 번씩 정상적으로 출력을 전달한다.
    
    결론은 OS는 일종의 illusion, 환상을 발생시킨다고 볼 수 있다. OS는 각각 하나의 CPU를 필요로 하는 여러 프로그램을 동시에 실행시킬 수 있으며, 마치 시스템에 여러 개의 CPU가 존재하는 것과 같이 보이게 한다. 즉, CPU에 대해 일종의 가상화를 적용한다.
    
    만약 두 프로그램이 정확히 동시에 작동해야만 한다면? → 이에 대한 policy가 어딘가에 존재할 것. resource manager를 따른다.
    
- Virtualizing Memory
    
    메모리에도 물론 가상화가 적용된다.
    
    malloc으로 메모리를 할당하고 그 주소를 출력하는 프로그램을 동시에 실행하면 출력되는 주소 역시 동일하다.
    
    물론, 두 프로세스가 동일한 물리적인 주소를 사용하는 것은 아니고, 실제로 출력되는 주소는 OS가 조작한 일종의 가상 주소다.
    
- Concurrency
    
    Concurrency는 간단히 말해, 작업이 동시에 실행되도록 보이게 하는 것이다. 즉, task A와 B를 동시에 실행하는 것처럼 보이도록 하며, 그 결과가 A와 B를 각각 실행한 것과 같아야 한다.
    
    다만, 프로그램을 대충 짜서 때려넣으면 문제가 생길 수 있다. 책의 예제에서는 2개의 thread가 각각 N번의 loop를 돌며 한 번의 loop마다 공유 변수에 1을 더하는 프로그램을 소개한다. Concurrency를 보장한다면 실행 결과 공유 변수의 값은 2N이 되어야 하지만, N을 좀 키우다 보면 2N보다 작은 예상할 수 없는 값이 나온다.
    
    이는 한 번의 loop를 돌리는 과정이 atomic하지 않기 때문이다. 1 loop는 공유 변수에서 값을 가져오고, 1을 더하고, 돌려놓는 3가지 파트로 구성되는데, 중간에 interrupt가 발생해 다른 thread로 전환되면 문제가 발생할 수 있다.
    
    분명히 나중에 나올 것입니다
    
    아님ㅁ망고
    
- Persistence
    
    시스템 메모리는 기본적으로 volatile하다. 즉, 전원이 꺼지면 데이터를 다 까먹는다.
    
    따라서, 운영체제는 이러한 데이터들을 저장해야 할 필요가 있다면 이를 persistently하게 저장해야 한다. 즉, 파일 시스템을 안정성 있고 복구 가능하게 만들어야 한다.
    
- Design Goals
    
    결국, 운영체제는 앞선 3가지 요소 - Virtualization, Concurrency, Persistence - 를 가능하게 만들어져야 한다.
    
    이를 위해서 abstraction들, 즉 추상화를 구상하여 lower-level의 요소를 higher-level로 가공해나갈 필요가 있다. 예를 들어, C를 사용해 어셈블리어와 회로 구성에 대한 이해 없이 프로그램을 간단하게 작성할 수 있다.
    
    구현하고자 하는 OS에 따라 다른 종류의 목표도 세울 수 있다.
    
    - Performance - 주어진 하드웨어 내에서 얼마나 빠른 처리가 가능한가?
    - Protection - 프로세스 간의 보호. Isolation 등으로 달성 가능
    - Energy efficiency
    - mobility 등…
- Some History
    
    귀찮아서 안 할거임